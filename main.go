package main

import (
	"gopkg.in/yaml.v3"
	"log"
	"net/http"
	"os"

	"github.com/gin-gonic/gin"
)

/*
hooks:
  - name: hello
    command: echo "this is the hello hook"
	script:
  - name: world
    command:
	script: /path/to/script
*/

// type AutoGenerated struct {
// 	Config struct {
// 		Host         string `yaml:"Host"`
// 		Port         string `yaml:"Port"`
// 		DefaultToken string `yaml:"DefaultToken"`
// 		Hooks        struct {
// 			Hookname1 struct {
// 				Command string `yaml:"Command"`
// 				Script  string `yaml:"Script"`
// 			} `yaml:"hookname1"`
// 		} `yaml:"Hooks"`
// 	} `yaml:"config"`
// }

type Config struct {
	Host        string                `yaml:"Host"`
	Port        string                `yaml:"Port"`
	GlobalToken string                `yaml:"GlobalToken"`
	Hooks       map[string]HookConfig `yaml:"Hooks"`
}

type HookConfig struct {
	Command string `yaml:"Command"`
	Script  string `yaml:"Script"`
	Token   string `yaml:"Token"`
}

func (h HookConfig) Run(hookName string) {
	log.Println("Running", hookName)
	// TODO: run command or script. Maybe set gin context as environment var?
}

func (h HookConfig) Authorized(token string) bool {
	isAuthed := token == h.Token || token == config.GlobalToken
	log.Println("Authorization valid:", isAuthed)
	return isAuthed
}

func ParseConfig(path string) Config {

	buf, err := os.ReadFile(path)
	if err != nil {
		log.Fatal("Failed to open", path, err)

	}

	c := &Config{}
	if err := yaml.Unmarshal(buf, c); err != nil {
		log.Fatal(err)
	}

	return *c

}

var config Config

func main() {
	router := gin.Default()
	config = ParseConfig(os.Getenv("HOOKER_CONFIG"))

	router.GET("/:hook", func(c *gin.Context) {

		hookName := c.Param("hook")
		val, ok := config.Hooks[hookName]
		token := c.Request.Header["Token"][0]

		if ok && val.Authorized(token) {
			val.Run(hookName)
			c.Status(http.StatusOK)
		} else {
			log.Println(hookName, "does not exist")
			c.Status(http.StatusNotFound)
		}

	})

	router.Run(config.Host + ":" + config.Port)
}
